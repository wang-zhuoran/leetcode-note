# 深度解析 KMP 算法：从零到一的直觉推导

## 1. 核心思想：主串指针不回头
在字符串匹配任务中，给定主串 `S` 和模式串 `P`，暴力匹配（Brute Force）在失配时会回溯主串指针 `i`。而 **KMP 的精髓在于：利用已经匹配过的部分信息，让主串指针 `i` 永远不回退，只通过移动模式串指针 `j` 来找寻下一个匹配点。**

## 2. `next` 数组
`next` 数组是 KMP 的灵魂，它本质上是一张**“撤退地图”**。

### (1) 什么是前缀和后缀？
以字符串 `"ABCAB"` 为例：
* **前缀**：必须包含首字母，但不包含末尾字母。`{A, AB, ABC, ABCA}`
* **后缀**：必须包含末尾字母，但不包含首字母。`{B, AB, CAB, BCAB}`
* **最长相等前后缀**：在上述集合的交集中，长度最长的是 `"AB"`，长度为 **2**。

### (2) 长度即索引的巧妙设计
在 `0` 起始的索引体系中，**“前缀的长度”恰好等于“该前缀末尾的下一个字符的索引”**。
* 如果相等前后缀长度是 `2`（即 `P[0], P[1]`），那么下一个要比对的索引正是 `2`（即 `P[2]`）。
## 3. 算法实现步骤

### 第一步：构建 `next` 数组 (`getNext`)
我们要让模式串自己和自己匹配。`i` 代表后缀末尾，`j` 代表前缀末尾（同时也是长度）。

```cpp
void getNext(vector<int>& next, string& s) {
    int j = 0;
    next[0] = 0; // 第一个字符没有任何前后缀，固定为 0
    
    for (int i = 1; i < s.size(); i++) {
        // 【易错点 1】：回溯必须用 while
        // 如果 s[i] 和 s[j] 不匹配，j 要不断向回跳
        while (j > 0 && s[i] != s[j]) { 
            j = next[j - 1]; 
        }
        
        // 【易错点 2】：比较的是字符，不是 next 数组的值
        if (s[i] == s[j]) {
            j++; 
        }
        
        // 每个位置 i 对应的最长相等前后缀长度就是此时的 j
        next[i] = j; 
    }
}
```
### 第二步 进行匹配 (`strStr`)
主串指针 i 遍历一遍，绝不回退。
```cpp
int strStr(string haystack, string needle) {
    if (needle.empty()) return 0;
    int n = needle.size();
    int m = haystack.size();
    
    vector<int> next(n);
    getNext(next, needle); // 先算好地图
    
    int j = 0;
    for (int i = 0; i < m; i++) {
        // 如果当前字符不匹配，j 按照地图跳跃
        while (j > 0 && haystack[i] != needle[j]) {
            j = next[j - 1];
        }
        
        // 匹配成功，j 尝试向前进
        if (haystack[i] == needle[j]) {
            j++;
        }
        
        // j 走到了 needle 的尽头，说明全对上了
        if (j == n) {
            return i - n + 1; // 返回起始索引
        }
    }
    return -1;
}
```
### 第三部分：避坑指南与总结

## 4. 易错点避坑指南（复习必读）

| 易错点 | 错误写法 | 正确写法 | 原因 |
| :--- | :--- | :--- | :--- |
| **比较对象** | `s[i] != next[j]` | `s[i] != s[j]` | `next` 存的是长度，我们要比的是字符内容。 |
| **回退逻辑** | `if (s[i] != s[j])` | `while (j > 0 && ...)` | 跳一次可能还不匹配，需要一直跳到匹配或回到开头。 |
| **回退位置** | `j = next[j]` | `j = next[j - 1]` | 必须查找“前一个位置”已经确定的最长前后缀信息。 |
| **赋值位置** | `next[i]=j` 放在 `if` 里 | 放在 `for` 循环最后 | 即使没有匹配（j=0），当前位置的 `next[i]` 也需要被赋值。 |

## 5. 为什么 `j = next[j-1]` 有效？
当 `P[j]` 失配时，我们已知 `P[0...j-1]` 这一段是匹配成功的。
1.  **S 的后缀 = P 的后缀**（匹配战果）
2.  **P 的后缀 = P 的前缀**（`next` 数组定义的自相似性）
3.  **结论**：**S 的后缀 = P 的前缀**。
我们直接把 P 的前缀拉过来对齐 S 的后缀，从而跳过了大量无意义的机械比对。

---
**Tip**: 复习时，拿纸笔模拟一次 `needle = "aabaaac"` 的 `next` 数组生成过程，如果能准确算出 `[0, 1, 0, 1, 2, 2, 0]`，说明你已经完全掌握了！
